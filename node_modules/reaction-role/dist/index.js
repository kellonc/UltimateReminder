"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactionRole = void 0;
const bookman_1 = require("bookman");
const discord_js_1 = require("discord.js");
const lodash_1 = require("lodash");
const pogger = __importStar(require("pogger"));
class ReactionRole extends discord_js_1.Client {
    constructor(token, mongodb_uri, logging = true) {
        super({
            partials: ["CHANNEL", "REACTION", "MESSAGE"],
        });
        this.config = {};
        this.ready = false;
        this.exportConfig = () => this.config;
        this._token = token;
        this.mongodb_uri = mongodb_uri;
        this.logging = logging;
        if (mongodb_uri) {
            const adapter = new bookman_1.MongoDBAdapter({
                databaseName: "RR",
                defaultDir: "ReactionRole",
                mongodbURL: mongodb_uri,
            });
            const db = new bookman_1.Database(adapter);
            this.onGet(() => __awaiter(this, void 0, void 0, function* () {
                const data = (yield db.get("config"));
                return data;
            }))
                .onSet((new_data) => __awaiter(this, void 0, void 0, function* () {
                yield db.set("config", new_data);
            }))
                .onDelete((message_id) => __awaiter(this, void 0, void 0, function* () {
                yield db.delete(`config.${message_id}`);
            }));
        }
    }
    onGet(on_get) {
        this.on_get = on_get;
        return this;
    }
    onSet(on_set) {
        this.on_set = on_set;
        return this;
    }
    onDelete(on_delete) {
        this.on_delete = on_delete;
        return this;
    }
    createOption(emoji, roles, add_message, remove_message) {
        const parsed = discord_js_1.Util.parseEmoji(emoji);
        if (!parsed)
            throw new Error("Valid emoji expected");
        return {
            emoji: parsed.id || parsed.name,
            roles,
            add_message,
            remove_message,
        };
    }
    createMessage(channel_id, message_id, limit, ...emojis) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = {
                channel_id,
                emojis,
                message_id,
                limit,
                type: "regular",
            };
            lodash_1.set(this.config, message_id, message);
            if (this.on_set)
                yield this.on_set(this.config);
            return message;
        });
    }
    deleteMessage(message_id) {
        return __awaiter(this, void 0, void 0, function* () {
            lodash_1.unset(this.config, message_id);
            if (this.on_delete)
                yield this.on_delete(message_id);
            return this.config;
        });
    }
    importConfig(config) {
        return __awaiter(this, void 0, void 0, function* () {
            lodash_1.merge(this.config, config);
            if (this.on_get) {
                const saved = (yield this.on_get()) || {};
                lodash_1.merge(saved, this.config);
                if (this.on_set) {
                    yield this.on_set(saved);
                }
            }
            return this.config;
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.logging)
                pogger.event("[ReactionRole]: Spawning ReactionRole...");
            this.on("ready", () => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                if (this.logging)
                    pogger.info(`[ReactionRole]: Logged in as ${(_a = this.user) === null || _a === void 0 ? void 0 : _a.tag}!`);
                if (this.on_get) {
                    pogger.event("[ReactionRole]: Loading data from database.");
                    const saved = (yield this.on_get());
                    if (saved) {
                        pogger.info(`[ReactionRole]: Importing ${Object.keys(saved).length} messages...`);
                        this.importConfig(saved);
                        pogger.success(`[ReactionRole]: Successfully imported ${Object.keys(saved).length} messages!`);
                    }
                    else
                        pogger.warning("[ReactionRole]: Database is empty.");
                }
                if (this.logging)
                    pogger.event("[ReactionROle]: Fetching messages.");
                if (this.logging)
                    pogger.info(`[ReactionRole]: Fetching ${Object.keys(this.config).length} messages...`);
                for (const message_id in this.config) {
                    const message = this.config[message_id];
                    const channel = (yield this.channels
                        .fetch(message.channel_id)
                        .catch(() => undefined));
                    if (!channel || channel.type != "text") {
                        this.deleteMessage(message.message_id);
                        continue;
                    }
                    const msg = yield channel.messages
                        .fetch(message.message_id)
                        .catch(() => undefined);
                    if (!msg || msg.deleted) {
                        this.deleteMessage(message.message_id);
                        continue;
                    }
                    for (const emoji of message.emojis) {
                        if (!msg.reactions.cache.has(emoji.emoji) ||
                            !((_b = msg.reactions.cache
                                .get(emoji.emoji)) === null || _b === void 0 ? void 0 : _b.users.cache.has((_c = this.user) === null || _c === void 0 ? void 0 : _c.id)))
                            yield msg.react(emoji.emoji);
                    }
                }
                if (this.logging)
                    pogger.success(`[ReactionRole]: Successfully fetched ${Object.keys(this.config).length} messages!`);
                this.ready = true;
                if (this.logging)
                    pogger.success("[ReactionRole]: Ready ðŸš€!");
            }));
            this.on("messageReactionAdd", (reaction, user) => __awaiter(this, void 0, void 0, function* () {
                var _d;
                if (!this.ready)
                    return;
                if (reaction.partial)
                    reaction = yield reaction.fetch();
                if (!reaction.message.guild)
                    return;
                if (user.partial)
                    user = yield user.fetch();
                if (!reaction.message.guild.members.cache.has(user.id))
                    return;
                if (!lodash_1.has(this.config, reaction.message.id))
                    return;
                const message = lodash_1.get(this.config, reaction.message.id);
                if (message.limit > 0) {
                    const reactions = reaction.message.reactions.cache.filter((r) => message.emojis.some((emoji) => emoji.emoji == (r.emoji.id || r.emoji.name)) && r.users.cache.has(user.id));
                    if (reactions.size > message.limit)
                        return yield reaction.users.remove(user.id);
                }
                const emoji = message.emojis.find((emoji) => emoji.emoji == (reaction.emoji.id || reaction.emoji.name));
                if (!emoji)
                    return;
                const member = (_d = reaction.message.guild) === null || _d === void 0 ? void 0 : _d.member(user.id);
                const roles_to_add = emoji.roles.filter((id) => !member.roles.cache.has(id));
                if (roles_to_add.length < 1)
                    return;
                yield member.roles.add(roles_to_add);
                if (emoji.add_message)
                    yield member.send(emoji.add_message).catch(() => undefined);
            }));
            this.on("messageReactionRemove", (reaction, user) => __awaiter(this, void 0, void 0, function* () {
                var _e;
                if (!this.ready)
                    return;
                if (reaction.partial)
                    reaction = yield reaction.fetch();
                if (!reaction.message.guild)
                    return;
                if (user.partial)
                    user = yield user.fetch();
                if (!reaction.message.guild.members.cache.has(user.id))
                    return;
                if (!lodash_1.has(this.config, reaction.message.id))
                    return;
                const message = lodash_1.get(this.config, reaction.message.id);
                const emoji = message.emojis.find((emoji) => emoji.emoji == (reaction.emoji.id || reaction.emoji.name));
                if (!emoji)
                    return;
                const member = (_e = reaction.message.guild) === null || _e === void 0 ? void 0 : _e.member(user.id);
                const roles_to_remove = emoji.roles.filter((id) => member.roles.cache.has(id));
                if (roles_to_remove.length < 1)
                    return;
                yield member.roles.remove(roles_to_remove);
                if (emoji.remove_message)
                    yield member.send(emoji.remove_message).catch(() => undefined);
            }));
            const token = yield this.login(this._token);
            if (this.logging)
                pogger.success("[ReactionRole]: ReactionRole spawned successfully!");
            return token;
        });
    }
    reInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.destroy();
            const rr = new ReactionRole(this._token, this.mongodb_uri);
            yield rr.importConfig(this.config);
            return rr;
        });
    }
}
exports.ReactionRole = ReactionRole;
