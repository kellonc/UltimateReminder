import * as nodeRedis from "redis";
import { Commands } from "../generated/interface";
import { Push } from "../push";
declare module "../generated/interface" {
    interface ResultTypes<Result, Context> {
        /**
         * This determines the correct type for a node_redis multi result. e.g. `multi.keys('foo:*')` should be a multi instance
         * which will include include a `string[]` value in the array eventually returned by `.exec()`.
         */
        node_redis_multi: WrappedNodeRedisMulti<Push<Extract<Context, {
            results: unknown[];
        }>["results"], MultiResult<Result>>>;
    }
}
export declare type MultiResult<T> = T | nodeRedis.ReplyError;
/**
 * types from multis depend on a bunch of type inference so in IDEs they can end up looking like:
 * ```
 * Push<Push<Push<[], string>, "OK">, string[]>
 * ```
 *
 * This makes them appear as
 * ```
 * [string, "OK", string[]]
 * ```
 *
 * Taken from https://github.com/sindresorhus/type-fest/pull/157
 */
export declare type Simplify<T> = {
    [K in keyof T]: T[K];
};
export declare const WrappedNodeRedisMultiImpl: {
    new (multi: nodeRedis.Multi): {
        readonly nodeRedisMulti: nodeRedis.Multi;
        readonly exec: WrappedNodeRedisMulti["exec"];
        readonly exec_atomic: WrappedNodeRedisMulti["exec_atomic"];
    };
    create(multi: nodeRedis.Multi): WrappedNodeRedisMulti;
};
export interface WrappedNodeRedisMulti<Results extends unknown[] = [
]> extends Pick<Commands<{
    type: "node_redis_multi";
    results: Results;
}>, Exclude<keyof Commands<{
    type: "node_redis_multi";
    results: Results;
}>, "exec">> {
    /** Execute all commands issued after multi */
    exec(): Promise<Results>;
    /** Execute all commands issued after multi */
    exec_atomic(): Promise<Results>;
}
