"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodeRedisClient = exports.addNodeRedisCommand = void 0;
const nodeRedis = require("redis");
const flatten_1 = require("../flatten");
const multi_1 = require("./multi");
const WrappedNodeRedisClientImpl = class _WrappedNodeRedisClient {
    constructor(nodeRedis) {
        this.nodeRedis = nodeRedis;
        this.redis = nodeRedis;
    }
    multi() {
        return multi_1.WrappedNodeRedisMultiImpl.create(this.nodeRedis.multi());
    }
    batch() {
        return multi_1.WrappedNodeRedisMultiImpl.create(this.nodeRedis.batch());
    }
    end(flush) {
        return this.nodeRedis.end(flush);
    }
};
const addCommands = (methods) => {
    methods.forEach(method => {
        WrappedNodeRedisClientImpl.prototype[method] = function (...args) {
            return new Promise((resolve, reject) => {
                const flattenedArgs = [
                    ...flatten_1.flattenDeep(args),
                    (err, reply) => (err ? reject(err) : resolve(reply)),
                ];
                return this.nodeRedis[method](...flattenedArgs);
            });
        };
    });
};
addCommands(Object.keys(nodeRedis.RedisClient.prototype).filter(method => method === method.toLowerCase() && !(method in WrappedNodeRedisClientImpl.prototype)));
/** add a command that isn't included by default in node_redis e.g. `addCommand('lpos')` */
const addNodeRedisCommand = (command) => {
    nodeRedis.addCommand(command);
    addCommands([command]);
};
exports.addNodeRedisCommand = addNodeRedisCommand;
const createNodeRedisClient = (...clientArgs) => {
    const nodeRedisInstance = typeof clientArgs[0] === "object" && typeof clientArgs[0].scan === "function"
        ? clientArgs[0]
        : nodeRedis.createClient.apply(null, clientArgs);
    return new WrappedNodeRedisClientImpl(nodeRedisInstance);
};
exports.createNodeRedisClient = createNodeRedisClient;
//# sourceMappingURL=index.js.map